local _, LRP = ...

local SharedMedia = LibStub("LibSharedMedia-3.0")

local buttonSize = 24
local spacing = 8
local iconSize = 24
local editBoxHeight = 24
local currentGlowType -- The glow type that is currently being previewed

-- Unique identifier that this reminder is indexed by in SavedVariables (as generated by LRP:GenerateUniqueID)
-- Along with the encounterID and difficulty, this is used to uniquely identify a reminder
local reminderID 

local spellEvents = {
    SPELL_CAST_START = true,
    SPELL_CAST_SUCESS = true,
    SPELL_AURA_APPLIED = true,
    SPELL_AURA_REMOVED = true,
    UNIT_SPELLCAST_START = true,
    UNIT_SPELLCAST_SUCCEEDED = true
}

local reminderData = {
    load = {
        type = "ALL", -- Who this reminder should show for ("ALL", "NAME", "POSITION", "CLASS_SPEC", "GROUP", or "ROLE")
        -- name = "",
        -- class = "",
        -- spec = "",
        -- role = ""
        -- position = ""
        -- group = 1
    },
    trigger = {
        -- relativeTo = {
        --     event = "SPELL_CAST_SUCCESS", -- Event that the reminder is relative to
        --     value = 123456, -- spellID/npc ID/boss text relating to the above event
        --     count = 1 -- Count of above event/value combination that the reminder is relative to
        -- },
        time = 0, -- Time relative to pull (or event) when the reminder should finish showing
        duration = 8, -- Number of seconds the reminder shows for
        linger = 0, -- Number of seconds the reminder should show after it expires (only for hide-on-use spell reminders)
        hideOnUse = true -- Hides the spell reminder when you cast the spell
    },
    display = {
        type = "TEXT", -- "TEXT" or "SPELL"
        -- spellID = 0, -- Spell ID that should show (in case of SPELL reminder)
        text = "", -- Reminder text (in case of TEXT reminder)
        color = {
            r = 1,
            g = 1,
            b = 1
        }
    },
    tts = { -- Whether text-to-speech should play for this reminder
        enabled = false,
        time = 0, -- Time duration on the reminder when the TTS should play.
        voice = 0
    },
    sound = { -- Whether sound should play for this reminder
        enabled = false,
        time = 0, -- Time duration on the reminder when the sounbd should play.
        file = "Interface\\Addons\\TimelineReminders\\Media\\Sounds\\TR_Beep.mp3" -- Sound file
    },
    countdown = {
        enabled = false,
        start = 3, -- From when the countdown should start (in seconds)
        voice = "Sara" -- Davis/Maise/Sara/Steffan
    },
    glow = {
        enabled = false,
        names = {}, -- Player name(s) to glow while the reminder is showing
        type = "PIXEL", -- "PIXEL", "AUTOCAST", "BUTTON", or "PROC" (PROC only available on retail)
        color = {
            r = 0.95,
            g = 0.95,
            b = 0.32
        }
    }
}

local emptyReminder = CopyTable(reminderData) -- Used to reset config back to default

local windowWidth = 500
local windowHeight = 500

-- Constants for use in dropdowns
local spellDropdownShouldUpdate = true
local playerClass, playerClassFile, playerClassID = UnitClass("player")
local classSortOrder = tInvert(CLASS_SORT_ORDER) -- Used for ordering dropdowns

-- Widgets
local reminderTypeDropdownInfoTable, soundDropdownInfoTable
local targetNameEditBox, targetDropdown, relativeToDropdown, timeEditBox, durationSlider, reminderColorPicker, textReminderEditBox
local spellReminderEditBoxIcon, spellReminderEditBox, hideOnUseCheckButton, reminderTypeDropdown, ttsTimeSlider, ttsCheckButton
local glowNamesEditBox, glowCheckButton, acceptButton, deleteButton, relativeToValueEditBox, relativeToCountEditBox, relativeToSpellIcon
local glowTypeDropdown, glowColorPicker, makeDefaultButton, testButton, glowPreviewFrame, ttsVoiceDropdown, ttsAliasEditBox, lingerSlider
local soundCheckButton, soundTimeSlider, soundDropdown, countdownCheckButton, countdownTimeSlider, countdownVoiceDropdown, exportButton

-- On some operating systems, voices becomes available only after the addon loads
-- We call this function on VOICE_CHAT_TTS_VOICES_UPDATE to account for that
local function GetVoiceDropdownInfoTable()
    local ttsVoiceDropdownInfoTable = {}
    local availableTtsVoices = C_VoiceChat.GetTtsVoices()

    -- If user has no TTS voices installed on their machine, display it
    if not (availableTtsVoices and next(availableTtsVoices)) then
        availableTtsVoices = {
            {
                voiceID = 0,
                name = "No TTS voices available"
            }
        }
    end

    for _, voiceInfo in ipairs(availableTtsVoices) do
        local text = voiceInfo.name
        local first, second = text:match("(.-)%s*Desktop%s*(.+)")

        -- Remove "Desktop"
        if first and second then
            text = string.format("%s %s", first, second)
        end

        -- Remove "Microsoft" at start of name
        text = text:match("^Microsoft%s*(.+)") or text

        table.insert(
            ttsVoiceDropdownInfoTable,
            {
                text = text,
                value = voiceInfo.voiceID
            }
        )
    end

    return ttsVoiceDropdownInfoTable
end

-- For the currently set timelineData, find the phase that a reminder is relative to
-- This is used when loading in a reminder to know which phase to select from the dropdown
local function GetPhaseFromReminder(_reminderData)
    local timelineData = LRP:GetCurrentTimelineInfo().timelineData
    local relativeTo = _reminderData.trigger.relativeTo
    
    if not relativeTo then
        return 0 -- Relative to pull
    end

    local event = relativeTo.event
    local value = relativeTo.value
    local count = relativeTo.count

    for phaseCount, phaseInfo in ipairs(timelineData.phases) do
        if phaseInfo.event == event and phaseInfo.value == value and phaseInfo.count == count then
            return phaseCount
        end
    end

    -- If we are here, no phase was matched, even though the reminder is relative to an event (not to pull)
end

-- Creates (or updates) a reminder from the provided id/data
function LRP:CreateReminder(_reminderID, _reminderData)
    local timelineInfo = LRP:GetCurrentTimelineInfo()
    local reminderTable = timelineInfo.reminders

    -- Add export data
    local triggerText, rest = LRP:ExportReminderToMRT(_reminderData)

    _reminderData.export = {
        mrt = {
            trigger = triggerText,
            rest = rest
        }
    }

    -- Save reminder
    reminderTable[_reminderID] = CopyTable(_reminderData)

    LRP:SetExportStale()
end

function LRP:DeleteReminder(_reminderID)
    local reminders = LRP:GetCurrentTimelineInfo().reminders

    reminders[_reminderID] = nil
    
    LRP:SetExportStale()
    LRP:BuildReminderLines()

    -- Only close the reminder config window if we deleted the reminder that is opened
    if reminderID == _reminderID then
        LRP.reminderConfig:Hide()
    end
end

-- Sets the config to match an existing reminder
-- If no reminder matching this encounterID/difficulty/reminderID combination exists, loads in default settings
function LRP:LoadReminder(id)
    LRP:CloseSingleExport()

    local timelineInfo = LRP:GetCurrentTimelineInfo()
    local timelineData = timelineInfo.timelineData
    local reminders = timelineInfo.reminders

    reminderID = id
	local newReminder = reminders[id]

	if not newReminder then
        if LiquidRemindersSaved.settings.defaultReminder then
            newReminder = CopyTable(LiquidRemindersSaved.settings.defaultReminder)
        else
		    newReminder = CopyTable(emptyReminder)
        end

        -- By default new reminders are set to target the player's current class
        local class = UnitClassBase("player")

        newReminder.load.type = "CLASS_SPEC"
        newReminder.load.class = class
        newReminder.load.spec = class -- We set spec equal to class to indicate that it's class-wide

        -- Glow should always be disabled by default (regardless of default settings)
        -- And glow names should also be empty
        newReminder.glow.enabled = false
        newReminder.glow.names = {}
	end

    -- Populate the phase dropdown
	local infoTable = {
		[1] = {text = "Pull", value = 0}
	}

	for phaseCount, phaseInfo in ipairs(timelineData.phases) do
		table.insert(
			infoTable,
			{
				text = phaseInfo.name,
				value = phaseCount
			}
		)
	end

    table.insert(
        infoTable,
        {
            text = "Event",
            value = "EVENT",
            children = {
                [1] = {
                    text = "SPELL_CAST_START",
                    value = "SPELL_CAST_START"
                },
                [2] = {
                    text = "SPELL_CAST_SUCCESS",
                    value = "SPELL_CAST_SUCCESS"
                },
                [3] = {
                    text = "SPELL_AURA_APPLIED",
                    value = "SPELL_AURA_APPLIED"
                },
                [4] = {
                    text = "SPELL_AURA_REMOVED",
                    value = "SPELL_AURA_REMOVED"
                },
                [5] = {
                    text = "UNIT_SPELLCAST_START",
                    value = "UNIT_SPELLCAST_START"
                },
                [6] = {
                    text = "UNIT_SPELLCAST_SUCCEEDED",
                    value = "UNIT_SPELLCAST_SUCCEEDED"
                },
                [7] = {
                    text = "UNIT_DIED",
                    value = "UNIT_DIED"
                },
                [8] = {
                    text = "CHAT_MSG_MONSTER_YELL",
                    value = "CHAT_MSG_MONSTER_YELL"
                }
            }
        }
    )

	relativeToDropdown:SetInfoTable(infoTable)

    -- Load
    local targetType = newReminder.load.type

    if targetType == "ALL" then
        targetDropdown:SetValue({1})
    elseif targetType == "NAME" then
        targetDropdown:SetValue({2})
    elseif targetType == "CLASS_SPEC" then
        local class = newReminder.load.class
        local spec = newReminder.load.spec

        targetDropdown:SetValue({3, classSortOrder[class], spec == class and 1 or spec + 1})
    elseif targetType == "ROLE" then
        local role = newReminder.load.role

        targetDropdown:SetValue({4, role == "TANK" and 1 or role == "HEALER" and 2 or 3})
    elseif targetType == "POSITION" then
        local position = newReminder.load.position

        targetDropdown:SetValue({5, position == "MELEE" and 1 or 2})
    elseif targetType == "GROUP" then
        local group = newReminder.load.group

        targetDropdown:SetValue({6, group})
    end

    targetNameEditBox:SetText(newReminder.load.name or "")

    -- Trigger
    local phaseFromTrigger = GetPhaseFromReminder(newReminder)

    if phaseFromTrigger then
        relativeToDropdown:SetValue({phaseFromTrigger + 1})
    else
        local eventIndices = {
            SPELL_CAST_START = 1,
            SPELL_CAST_SUCCESS = 2,
            SPELL_AURA_APPLIED = 3,
            SPELL_AURA_REMOVED = 4,
            UNIT_SPELLCAST_START = 5,
            UNIT_SPELLCAST_SUCCEEDED = 6,
            UNIT_DIED = 7,
            CHAT_MSG_MONSTER_YELL = 8
        }

        relativeToDropdown:SetValue({#infoTable, eventIndices[newReminder.trigger.relativeTo.event]})
        relativeToValueEditBox:SetText(newReminder.trigger.relativeTo.value or "")
        relativeToCountEditBox:SetText(newReminder.trigger.relativeTo.count or "")
    end
    
    timeEditBox:SetText(newReminder.trigger.time or "")
    durationSlider:SetValue(newReminder.trigger.duration)
    lingerSlider:SetValue(newReminder.trigger.linger)
    hideOnUseCheckButton:SetChecked(newReminder.trigger.hideOnUse)

    -- Display
    local reminderType = newReminder.display.type

    if reminderType == "TEXT" then
        reminderTypeDropdown:SetValue({1})
        spellReminderEditBox:SetText(0)
    else -- SPELL reminder
		reminderTypeDropdown:SetValue({3})
		spellReminderEditBox:SetText(newReminder.display.spellID or 0)
    end

    textReminderEditBox:SetText(newReminder.display.text or "")

    local color = newReminder.display.color
    reminderColorPicker:SetColor(color.r, color.g, color.b, 1)

    -- TTS
    ttsCheckButton:SetChecked(newReminder.tts.enabled)
    ttsTimeSlider:SetValue(newReminder.tts.time)

    reminderData.tts.voice = newReminder.tts.voice -- This is just to make sure the voice preview doesn't play
    ttsVoiceDropdown:SetValue({newReminder.tts.voice + 1})

    ttsAliasEditBox:SetText(newReminder.tts.alias or "")

    -- Sound
    soundCheckButton:SetChecked(newReminder.sound.enabled)
    soundTimeSlider:SetValue(newReminder.sound.time)

    reminderData.sound.file = newReminder.sound.file -- This is just to make sure the sound preview doesn't play

    local soundValue = {1} -- Use TR Beep as default value
    local currentSoundPath = reminderData.sound.file

    for i, info in ipairs(soundDropdownInfoTable) do
        if info.value == currentSoundPath then
            soundValue = {i}

            break
        end
    end

    soundDropdown:SetValue(soundValue)

    -- Countdown
    countdownCheckButton:SetChecked(newReminder.countdown.enabled)
    countdownTimeSlider:SetValue(newReminder.countdown.start)

    reminderData.countdown.voice = newReminder.countdown.voice -- This is just to make sure the countdown preview doesn't play

    local v = newReminder.countdown.voice
    countdownVoiceDropdown:SetValue(v == "Davis" and {1} or v == "Maise" and {2} or v == "Sara" and {3} or {4})
    
    -- Glow
    local glowNames = ""
    local glowColor = newReminder.glow.color
    local glowTypeToIndex = {
        PIXEL = 1,
        AUTOCAST = 2,
        BUTTON = 3,
        PROC = 4
    }

    glowCheckButton:SetChecked(newReminder.glow.enabled)

    for _, glowName in ipairs(newReminder.glow.names) do
        glowNames = string.format(glowNames == "" and "%s%s" or "%s, %s", glowNames, glowName)
    end

    glowNamesEditBox:SetText(glowNames)
    glowTypeDropdown:SetValue({glowTypeToIndex[newReminder.glow.type]})
    glowColorPicker:SetColor(glowColor.r, glowColor.g, glowColor.b, 1)
end

-- Sets the encounterID/phase/time based on where the user clicked the timeline
function LRP:CreateReminderFromTimeline(phase, combatTime)
	LRP:LoadReminder(LRP:GenerateUniqueID()) -- Reset config to default settings

    -- Set phase
	relativeToDropdown:SetValue({phase + 1})

	-- Set combat time
	timeEditBox:SetText(math.max(1, combatTime))

	LRP:CreateReminder(reminderID, reminderData)
    LRP:BuildReminderLines()

    LRP.reminderConfig:Show()
end

-- Updates the spell portion of the reminder type dropdown (should be called whenever a new spellID is detected)
local function UpdateSpellDropdown(initialUpdate)
    if not spellDropdownShouldUpdate then return end

    -- Initially update all class tables, subsequent updates only do our own
    for classFile, specTables in pairs(initialUpdate and LiquidRemindersSaved.spellBookData[LRP.flavorNumber] or {[playerClassFile] = LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile]}) do
        local classIndex = classSortOrder[classFile]

        for specID = 0, #specTables do -- 0 are class-wide spells
            local specTable = specTables[specID]

            reminderTypeDropdownInfoTable[2].children[classIndex].children[specID + 1].children = {}
            local targetTable = reminderTypeDropdownInfoTable[2].children[classIndex].children[specID + 1].children

            for spellID in pairs(specTable) do
                local spellInfo = LRP.GetSpellInfo(spellID)

                if spellInfo then -- It's possible that spells get removed between patches
                    table.insert(
                        targetTable,
                        {
                            text = spellInfo.name,
                            value = spellID,
                            icon = spellInfo.iconID
                        }
                    )
                end
            end

            table.sort(
                targetTable,
                function(spellA, spellB)
                    return spellA.text < spellB.text
                end
            )
        end
    end

    spellDropdownShouldUpdate = false
end

-- Iterates through the player's spellbook spells, and adds them to the SavedVariables table
-- These are then used to populate the spell dropdown
-- Whenever a new spell is found, spellDropdownShouldUpdate is set to true
local function CollectSpellBookData()
    local dropdownIndices = {
        [playerClass] = 0
    }

    for specIndex = 1, GetNumSpecializationsForClassID(playerClassID) do
        local _, specName = LRP.GetSpecializationInfoForClassID(playerClassID, specIndex)

        if not LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile][specIndex] then
            LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile][specIndex] = {}
        end

        dropdownIndices[specName] = specIndex
    end

    if LRP.isRetail then
        for tabIndex = 1, C_SpellBook.GetNumSpellBookSkillLines() do
            local skillLineInfo = C_SpellBook.GetSpellBookSkillLineInfo(tabIndex)

            local tabName = skillLineInfo.name
            local offset = skillLineInfo.itemIndexOffset
            local numSlots = skillLineInfo.numSpellBookItems
            local dropdownIndex = dropdownIndices[tabName]

            if dropdownIndex then -- Only index class/spec spells
                for spellIndex = offset + 1, offset + numSlots do
                    local spellInfo = C_SpellBook.GetSpellBookItemInfo(spellIndex, Enum.SpellBookSpellBank.Player)
                    local spellID = spellInfo.spellID
                    local isPassive = spellInfo.isPassive

                    if spellID and not isPassive then
                        if not LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile][spellID] then
                            spellDropdownShouldUpdate = true
                        end
        
                        LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile][dropdownIndex][spellID] = spellInfo.name:lower()
                    end
                end
            end
        end
    elseif LRP.isCata then
        for tabIndex = 1, GetNumSpellTabs() do
            local tabName, _, offset, numSlots = GetSpellTabInfo(tabIndex)
            local dropdownIndex = dropdownIndices[tabName]

            if dropdownIndex then -- Only index class/spec spells
                for spellIndex = offset + 1, offset + numSlots do
                    local spellName, _, spellID = GetSpellBookItemName(spellIndex, BOOKTYPE_SPELL)
                    local isPassive = spellID and IsPassiveSpell(spellID)

                    if spellID and not isPassive then
                        if not LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile][spellID] then
                            spellDropdownShouldUpdate = true
                        end
        
                        LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile][dropdownIndex][spellID] = spellName:lower()
                    end
                end
            end
        end
    end
end

-- Applies default settings (as set by the user) to a given reminder table
-- This is used when importing (or reading) reminders from MRT
function LRP:ApplyDefaultSettingsToReminder(reminder)
    local defaultReminder = LiquidRemindersSaved.settings.defaultReminder

    if not defaultReminder then return end
    
    -- Trigger
    reminder.trigger.duration = defaultReminder.trigger.duration
    reminder.trigger.hideOnUse = defaultReminder.trigger.hideOnUse
    reminder.trigger.linger = defaultReminder.trigger.linger

    -- Display
    reminder.display.color = CopyTable(defaultReminder.display.color)

    -- Glow
    reminder.glow.type = defaultReminder.glow.type
    reminder.glow.color = CopyTable(defaultReminder.glow.color)

    -- TTS
    reminder.tts = CopyTable(defaultReminder.tts)

    -- Sound
    reminder.sound = CopyTable(defaultReminder.sound)

    -- Countdown
    reminder.countdown = CopyTable(defaultReminder.countdown)
end

-- When talents are changed, lots of LEARNED_SPELL_IN_SKILL_LINE events happen
-- We only want to update the spellbook once, not on every event
local spellBookUpdateQueued

local function QueueSpellBookUpdate(initialUpdate)
    if not spellBookUpdateQueued then
        C_Timer.NewTimer(
            1,
            function()
                CollectSpellBookData()
                UpdateSpellDropdown(initialUpdate)

                spellBookUpdateQueued = false
            end
        )

        spellBookUpdateQueued = true
    end
end

local function UpdatePreviewGlow()
    -- Remove previous glow
    if currentGlowType then
        LRP:StopGlow(glowPreviewFrame, "preview_glow", currentGlowType)

        currentGlowType = nil
    end

    -- Add new glow (if any)
    if reminderData.glow.enabled then
        LRP:StartGlow(glowPreviewFrame, "preview_glow", reminderData.glow.type, reminderData.glow.color)

        currentGlowType = reminderData.glow.type
    end
end

function LRP:InitializeConfig()
    if not LiquidRemindersSaved.spellBookData[LRP.flavorNumber] then
        LiquidRemindersSaved.spellBookData[LRP.flavorNumber] = {}
    end

    if not LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile] then
        LiquidRemindersSaved.spellBookData[LRP.flavorNumber][playerClassFile] = {[0] = {}} -- Table 0 are class-wide spells
    end

    LRP.reminderConfig = LRP:CreateWindow("Config", true, true, false)

    LRP.reminderConfig:SetPoint("CENTER")
    LRP.reminderConfig:SetSize(windowWidth, windowHeight)
    LRP.reminderConfig:SetParent(LRP.window)
    LRP.reminderConfig:SetFrameStrata("DIALOG")
    LRP.reminderConfig:Hide()

    LRP:AddTooltip(LRP.reminderConfig.buttons[1], "Close without saving") -- First button is the exit button

    -- Duration slider
    durationSlider = LRP:CreateSlider(
        LRP.reminderConfig,
        "Duration",
        1,
        30,
        function(duration)
            reminderData.trigger.duration = duration

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    LRP:AddTooltip(durationSlider, "Number of seconds in advance that the reminder should appear, prior to the time configured below.")

    -- Linger slider
    lingerSlider = LRP:CreateSlider(
        LRP.reminderConfig,
        "Linger",
        0,
        10,
        function(linger)
            reminderData.trigger.linger = linger
            
            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    lingerSlider:SetPoint("LEFT", durationSlider, "RIGHT", spacing, 0)
    
    LRP:AddTooltip(lingerSlider, "Number of seconds that the reminder should show |cff29ff62after|r the regular duration is over.|n|nThis option is only available for spell reminders that hide on use.")
    
    -- Target dropdown/target name edit box
    targetNameEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Character name",
        function(name)
            reminderData.load.name = name

            if name == "" then
                targetNameEditBox:ShowHighlight(1, 0, 0)

                targetNameEditBox.secondaryTooltipText = "|cffff0000Character name must be provided for this reminder to show."
                LRP:RefreshTooltip()
            else
                targetNameEditBox:HideHighlight()

                targetNameEditBox.secondaryTooltipText = nil
                LRP:RefreshTooltip()
            end

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    local targetDropdownInfoTable = {
        [1] = {
            text = "All",
            value = "ALL"
        },
        [2] = {
            text = "Name",
            value = "NAME"
        },
        [3] = {
            text = "Class/spec",
            value = "CLASS_SPEC",
            children = {
            }
        },
        [4] = {
            text = "Role",
            value = "ROLE",
            children = {
                [1] = {
                    text = "Tank",
                    value = "TANK",
                    icon = "groupfinder-icon-role-large-tank"
                },
                [2] = {
                    text = "Healer",
                    value = "HEALER",
                    icon = "groupfinder-icon-role-large-heal"
                },
                [3] = {
                    text = "DPS",
                    value = "DAMAGER",
                    icon = "groupfinder-icon-role-large-dps"
                }
            }
        },
        [5] = {
            text = "Position",
            value = "POSITION",
            children = {
                [1] = {
                    text = "Melee",
                    value = "MELEE",
                    icon = LRP.classIcons["WARRIOR"]
                },
                [2] = {
                    text = "Ranged",
                    value = "RANGED",
                    icon = LRP.classIcons["HUNTER"]
                }
            }
        },
        [6] = {
            text = "Raid group",
            value = "GROUP",
            children = {
                {text = "1"},
                {text = "2"},
                {text = "3"},
                {text = "4"},
                {text = "5"},
                {text = "6"},
                {text = "7"},
                {text = "8"},
            }
        }
    }
    
    for classID = 1, GetNumClasses() do
        local _, classFile = GetClassInfo(classID)
        local colorStr = RAID_CLASS_COLORS[classFile].colorStr
        local coloredClass = LRP.coloredClasses[classFile]
        local classIcon = LRP.classIcons[classFile]
    
        local entry = {
            text = coloredClass,
            value = classFile,
            icon = classIcon,
            children = {
                [1] = {
                    text = coloredClass,
                    value = classFile,
                    icon = classIcon
                }
            }
        }
    
        for specIndex = 1, GetNumSpecializationsForClassID(classID) do
            local _, specName, _, specIcon = LRP.GetSpecializationInfoForClassID(classID, specIndex)
    
            if specName then
                table.insert(
                    entry.children,
                    {
                        text = string.format("|c%s%s|r", colorStr, specName),
                        value = specIndex,
                        icon = specIcon
                    }
                )
            end
        end
    
        local sortOrder = classSortOrder[classFile]
    
        if sortOrder then
            targetDropdownInfoTable[3].children[sortOrder] = entry
        end
    end
    
    targetDropdown = LRP:CreateDropdown(
        LRP.reminderConfig,
        "Target",
        targetDropdownInfoTable,
        function(targetType, ...)
            reminderData.load.type = targetType
    
            if targetType == "ROLE" then
                reminderData.load.role = ...
            elseif targetType == "POSITION" then
                local position = ...

                reminderData.load.position = position
            elseif targetType == "CLASS_SPEC" then
                local class, specIndex = ...

                reminderData.load.class = class
                reminderData.load.spec = specIndex
            elseif targetType == "GROUP" then
                local groupNum = ...

                reminderData.load.group = groupNum

                targetDropdown:OverrideText(string.format("Group %d", groupNum))
            end
            
            -- Position widgets
            if targetType == "NAME" then
                targetNameEditBox:Show()

                durationSlider:SetPoint("LEFT", targetNameEditBox, "RIGHT", spacing, 0)
            else
                targetNameEditBox:Hide()

                durationSlider:SetPoint("LEFT", targetDropdown, "RIGHT", spacing, 0)
            end

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    targetDropdown:SetPoint("TOPLEFT", LRP.reminderConfig, "TOPLEFT", spacing, -44)
    targetDropdown:SetWidth(140)
    LRP:AddTooltip(targetDropdown, "The character/class/spec/role that this reminder should show for.")
    
    -- Target name edit box
    targetNameEditBox:SetPoint("LEFT", targetDropdown, "RIGHT", spacing, 0)
    targetNameEditBox:SetSize(120, editBoxHeight)
    targetNameEditBox:SetShown(reminderData.targetType == "NAME")
    targetNameEditBox:SetMaxLetters(20)

    LRP:AddTooltip(targetNameEditBox, "Character that this reminder should show for. Does |cffff0000not|r support multiple entries.")
    
    -- Relative to spell ID edit box (SetPoint happens after relativeToDropdown initialization)
    relativeToValueEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "", -- This is set based on the type of event that this reminder is relative to
        function(value)
            if value == "" then value = 0 end -- Consider an empty edit box to represent 0

            local event = reminderData.trigger.relativeTo and reminderData.trigger.relativeTo.event
            local valueType = event and spellEvents[event] and "spell ID" or event == "UNIT_DIED" and "npc ID" or "text"

            -- Adjust the tooltip based on the value type
            if valueType then
                LRP:AddTooltip(relativeToValueEditBox, string.format("The %s corresponding to the event that this reminder is relative to.", valueType))
            end

            -- If the event is not CHAT_MSG_MONSTER_YELL, convert it to a number
            -- It should always be a spell ID or npc ID
            if event ~= "CHAT_MSG_MONSTER_YELL" then
                value = tonumber(value)

                if not value then
                    relativeToValueEditBox:SetText(0)

                    LRP:DisplaySingleExport(reminderID, reminderData)
    
                    return
                end

                if relativeToSpellIcon then
                    relativeToSpellIcon:SetSpellID(value)
                end
            end

            if reminderData.trigger.relativeTo then
                reminderData.trigger.relativeTo.value = value
            end

            -- If this type of event requires a spell ID, check if it's valid
            -- If not, highlight the value edit box
            if event and value then
                local timelineInfo = LRP:GetCurrentTimelineInfo()
                local timelineData = timelineInfo.timelineData

                if spellEvents[event] then
                    local spellInfo = LRP.GetSpellInfo(value)

                    if not spellInfo then
                        relativeToValueEditBox:ShowHighlight(1, 0, 0)

                        relativeToValueEditBox.secondaryTooltipText = string.format("|cffff0000Valid %s must be provided for this reminder to show.", valueType)
                        LRP:RefreshTooltip()
                        relativeToCountEditBox:Refresh() -- Count edit box highlight depends on this spell ID, refresh it

                        LRP:DisplaySingleExport(reminderID, reminderData)

                        return
                    end
                end
                
                -- Check if this event/value combination is present in timeline data
                for _, eventInfo in ipairs(timelineData.events) do
                    if event == eventInfo.event and value == eventInfo.value then
                        -- If we are here, the event/value combination is present in timeline data
                        -- Hide the highlight and the warning text
                        relativeToValueEditBox:HideHighlight()

                        relativeToValueEditBox.secondaryTooltipText = nil

                        LRP:RefreshTooltip()
                        relativeToCountEditBox:Refresh() -- Count edit box highlight depends on this spell ID, refresh it

                        LRP:DisplaySingleExport(reminderID, reminderData)

                        return
                    end
                end
            end

            -- If we are here, the event/value combination is not present in the timeline
            -- Show a highlight and add some secondary tooltip text explaining why the highlight is there
            relativeToValueEditBox:ShowHighlight(1, 1, 0)

            relativeToValueEditBox.secondaryTooltipText = string.format(
                "|cffffff00This event/%s combination is not included in the timeline data. As such, this reminder cannot be displayed on the timeline.|n|nThe reminder may still appear during the encounter if this event occurs!|r",
                valueType
            )

            LRP:RefreshTooltip()
            relativeToCountEditBox:Refresh() -- Count edit box highlight depends on this spell ID, refresh it

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    -- Relative to count edit box
    relativeToCountEditBox = LRP:CreateEditBox(
        relativeToValueEditBox,
        "Count",
        function(count)
            local event = reminderData.trigger.relativeTo and reminderData.trigger.relativeTo.event
            local valueType = event and spellEvents[event] and "spell ID" or event == "UNIT_DIED" and "npc ID" or "text"

            -- Adjust the tooltip based on the value type
            if valueType then
                LRP:AddTooltip(relativeToCountEditBox, string.format("The count of the event/%s combination that this reminder is relative to.", valueType))
            end

            if reminderData.trigger.relativeTo then
                reminderData.trigger.relativeTo.count = count
            end

            local value = reminderData.trigger.relativeTo and reminderData.trigger.relativeTo.value

            -- If the reminder is relative to a spell, and the spell ID is invalid, the spell ID edit box will already be highlighted
            -- In this case, don't also highlight the count edit box
            if spellEvents[event] then
                local spellInfo = value and LRP.GetSpellInfo(value)

                if not spellInfo then
                    relativeToCountEditBox:HideHighlight()

                    relativeToCountEditBox.secondaryTooltipText = nil
                    LRP:RefreshTooltip()
                    LRP:DisplaySingleExport(reminderID, reminderData)

                    return
                end
            end

            -- Hide/show a highlight based on whether this event/value/count combination is present in the timeline
            -- Add a tooltip warning explaning the situation
            if event and value then
                local timelineInfo = LRP:GetCurrentTimelineInfo()
                local timelineData = timelineInfo.timelineData

                local valueFound = false -- Whether the event/value combination is valid
                local countFound = false -- Whether the count is valid (in case the event is valid)
                local entryCount = 0

                for _, eventInfo in ipairs(timelineData.events) do
                    if event == eventInfo.event and value == eventInfo.value then
                        valueFound = true

                        if eventInfo.entries[count] then
                            countFound = true
                        end

                        entryCount = #eventInfo.entries
                       
                        break
                    end
                end

                -- If the event/value combination is not found, the value edit box will already be highlighted
                -- In this case, don't also highlight the count edit box
                if valueFound then
                    if countFound then
                        relativeToCountEditBox:HideHighlight()

                        relativeToCountEditBox.secondaryTooltipText = nil
                        LRP:RefreshTooltip()
                        LRP:DisplaySingleExport(reminderID, reminderData)

                        return
                    else
                        relativeToCountEditBox:ShowHighlight(1, 1, 0)

                        relativeToCountEditBox.secondaryTooltipText = string.format("|cffffff00There are only %d occurences of this event/%s combination on the timeline. As such, this reminder cannot be displayed on the timeline.|n|nThe reminder may still appear during the encounter if this number of events occur!|r", entryCount, valueType)
                        LRP:RefreshTooltip()
                        LRP:DisplaySingleExport(reminderID, reminderData)

                        return
                    end
                end
            end
            
            -- If we are here, the event/value combination is not present in the timeline at all (regardless of the count)
            -- Hide the highlight/tooltip warning in this case: the value edit box will already be highlighted
            relativeToCountEditBox:HideHighlight()

            relativeToCountEditBox.secondaryTooltipText = nil
            LRP:RefreshTooltip()
            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    relativeToCountEditBox:SetSize(50, editBoxHeight)
    relativeToCountEditBox:SetPoint("LEFT", relativeToValueEditBox, "RIGHT", spacing, 0)
    relativeToCountEditBox:SetNumeric(true)
    relativeToCountEditBox:SetMaxLetters(4)
    relativeToCountEditBox:SetMinimum(1)

    -- Relative to spell icon
    relativeToSpellIcon = LRP:CreateSpellIcon(relativeToCountEditBox)

    relativeToSpellIcon:SetParent(relativeToCountEditBox)
    relativeToSpellIcon:SetSize(iconSize, iconSize)
    relativeToSpellIcon:SetPoint("LEFT", relativeToCountEditBox, "RIGHT", spacing, 0)

    -- Time edit box
    timeEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Time",
        function(newTime)
            reminderData.trigger.time = newTime

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    timeEditBox:SetHeight(editBoxHeight)
    timeEditBox:SetNumericFullRange(true)
    timeEditBox:SetMaxLetters(8)
    timeEditBox:SetMinimum(1)
    
    LRP:AddTooltip(timeEditBox, "Time (in seconds) after the selected phase that the reminder should |cff29ff62finish|r showing.")

    -- Relative to dropdown
    relativeToDropdown = LRP:CreateDropdown(
        LRP.reminderConfig,
        "Relative to",
        {
            [1] = {text = "Pull", value = 0},
            [2] = {text = "Phase 1", value = 1},
            [3] = {text = "Intermission 1", value = 2},
            [4] = {text = "Phase 2", value = 3},
            [5] = {text = "Intermission 2", value = 4},
            [6] = {text = "Phase 3", value = 5},
            [7] = {
                text = "Event",
                value = "EVENT",
                children = {
                    [1] = {
                        text = "SPELL_CAST_START",
                        value = "SPELL_CAST_START"
                    },
                    [2] = {
                        text = "SPELL_CAST_SUCCESS",
                        value = "SPELL_CAST_SUCCESS"
                    },
                    [3] = {
                        text = "SPELL_AURA_APPLIED",
                        value = "SPELL_AURA_APPLIED"
                    },
                    [4] = {
                        text = "SPELL_AURA_REMOVED",
                        value = "SPELL_AURA_REMOVED"
                    },
                    [5] = {
                        text = "UNIT_SPELLCAST_START",
                        value = "UNIT_SPELLCAST_START"
                    },
                    [6] = {
                        text = "UNIT_SPELLCAST_SUCCEEDED",
                        value = "UNIT_SPELLCAST_SUCCEEDED"
                    },
                    [7] = {
                        text = "UNIT_DIED",
                        value = "UNIT_DIED"
                    },
                    [8] = {
                        text = "CHAT_MSG_MONSTER_YELL",
                        value = "CHAT_MSG_MONSTER_YELL"
                    }
                }
            }
        }, -- This is just dummy data to illustrate what the structure is. In reality it's always loaded from timeline data.
        function(arg1, arg2)
            if arg1 == "EVENT" then -- Relative to an event that is not a phase transition, or to an unknown event (i.e. not in timeline data)
                if not reminderData.trigger.relativeTo then
                    reminderData.trigger.relativeTo = {}
                end

                reminderData.trigger.relativeTo.event = arg2
                relativeToValueEditBox:SetText(reminderData.trigger.relativeTo.value or "")
                relativeToCountEditBox:SetText(reminderData.trigger.relativeTo.count or "")

                -- Position widgets
                relativeToValueEditBox:Show()

                if arg2 == "CHAT_MSG_MONSTER_YELL" then
                    relativeToSpellIcon:Hide()

                    timeEditBox:SetPoint("LEFT", relativeToCountEditBox, "RIGHT", spacing, 0)

                    relativeToValueEditBox:SetSize(90 + spacing + iconSize, editBoxHeight)
                else
                    relativeToSpellIcon:Show()

                    timeEditBox:SetPoint("LEFT", relativeToSpellIcon, "RIGHT", spacing, 0)

                    relativeToValueEditBox:SetSize(110, editBoxHeight)
                end
                
                -- Change edit box title
                if arg2 == "UNIT_DIED" then
                    relativeToValueEditBox.title:SetText(string.format("|cFFFFCC00%s|r", "Npc ID"))
                    relativeToValueEditBox:SetNumeric(true)
                elseif arg2 == "CHAT_MSG_MONSTER_YELL" then
                    relativeToValueEditBox.title:SetText(string.format("|cFFFFCC00%s|r", "Text"))
                    relativeToValueEditBox:SetNumeric(false)
                else
                    relativeToValueEditBox.title:SetText(string.format("|cFFFFCC00%s|r", "Spell ID"))
                    relativeToValueEditBox:SetNumeric(true)
                end

                relativeToValueEditBox:Refresh() -- Value edit box highlight depends on this event, refresh it
            else -- Relative to a known phase event (or pull)
                if arg1 == 0 then -- Relative to pull
                    reminderData.trigger.relativeTo = nil
                else
                    local timelineInfo = LRP:GetCurrentTimelineInfo()
                    local timelineData = timelineInfo.timelineData
                    local phaseInfo = timelineData.phases[arg1]
                    
                    reminderData.trigger.relativeTo = {
                        event = phaseInfo.event,
                        value = phaseInfo.value,
                        count = phaseInfo.count
                    }
                end

                -- Position widgets
                relativeToValueEditBox:Hide()

                timeEditBox:SetWidth(80)
                timeEditBox:SetPoint("LEFT", relativeToDropdown, "RIGHT", spacing, 0)
            end

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    relativeToDropdown:SetPoint("TOPLEFT", targetDropdown, "BOTTOMLEFT", 0, -30)
    relativeToDropdown:SetWidth(140)
    LRP:AddTooltip(
        relativeToDropdown,
        "The phase (or event) that the reminder time is relative to." ..
        "|n|ne.g. if phase 2 starts at 1:00, and the time is set to 20, the reminder will finish showing at 1:20." ..
        "|n|n|cff29ff62This is auto-filled when creating a reminder on the timeline relative to a phase.|r"
    )

    relativeToValueEditBox:SetPoint("LEFT", relativeToDropdown, "RIGHT", spacing, 0)
    relativeToValueEditBox:SetMaxLetters(100)

    -- Reminder color picker
    reminderColorPicker = LRP:CreateColorPicker(
        LRP.reminderConfig,
        "Color",
        function(r, g, b)
            reminderData.display.color = {
                r = r,
                g = g,
                b = b
            }

            LRP:DisplaySingleExport(reminderID, reminderData)
        end,
        false
    )

    reminderColorPicker:SetSize(20, 20)

    LRP:AddTooltip(reminderColorPicker, "Color that the reminder will show up in.")
    
    -- Reminder type
    textReminderEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Text",
        function(text)
            reminderData.display.text = strtrim(text)

            if text == "" then
                textReminderEditBox:ShowHighlight(1, 0, 0)

                textReminderEditBox.secondaryTooltipText = "|cffff0000Text must be provided for this reminder to show.|r"
                LRP:RefreshTooltip()
            else
                textReminderEditBox:HideHighlight()

                textReminderEditBox.secondaryTooltipText = nil
                LRP:RefreshTooltip()
            end

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    spellReminderEditBoxIcon = LRP:CreateSpellIcon()
    
    spellReminderEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Spell ID",
        function(spellID)
            if type(spellID) == "string" and spellID ~= "" then -- Spell name input
                spellID = spellID:lower()

                local spellBookData = LiquidRemindersSaved.spellBookData[LRP.flavorNumber][UnitClassBase("player")]

                if spellBookData then
                    for _, specSpellTable in pairs(spellBookData) do
                        for _spellID, spellName in pairs(specSpellTable) do
                            if spellID == spellName then
                                spellReminderEditBox:SetText(_spellID)

                                LRP:DisplaySingleExport(reminderID, reminderData)

                                return
                            end
                        end
                    end
                end
            end

            spellID = tonumber(spellID)

            if spellID then
                local spellInfo = LRP.GetSpellInfo(spellID)

                reminderData.display.spellID = spellID
                spellReminderEditBoxIcon:SetSpellID(spellID)

                -- Check if a valid spell ID was provided
                if spellInfo then
                    spellReminderEditBox:HideHighlight()

                    spellReminderEditBox.secondaryTooltipText = nil
                    LRP:RefreshTooltip()
                else
                    spellReminderEditBox:ShowHighlight(1, 0, 0)

                    spellReminderEditBox.secondaryTooltipText = "|cffff0000Valid spell ID must be provided for this reminder to show.|r"
                    LRP:RefreshTooltip()
                end
            else
                spellReminderEditBox:SetText(0)
            end

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    hideOnUseCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "Hide on use",
        function(hideOnUse)
            reminderData.trigger.hideOnUse = hideOnUse

            lingerSlider:SetShown(reminderData.display.type == "SPELL" and reminderData.trigger.hideOnUse)

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    reminderTypeDropdownInfoTable = {
        [1] = {
            text = "Text",
            value = "TEXT"
        },
        [2] = {
            text = "Spell",
            value = "SPELL",
            children = {}
        },
        [3] = {
            text = "Spell ID",
            value = "SPELLID"
        }
    }
    
    for classID = 1, GetNumClasses() do
        local className, classFile = GetClassInfo(classID)
        local colorStr = RAID_CLASS_COLORS[classFile].colorStr
        local coloredClass = string.format("|c%s%s|r", colorStr, className)

        local classIcon = string.format("interface\\icons\\classicon_%s.blp", classFile:lower())

        -- For some reason the regular class icon file is missing for cata
        if LRP.isCata and classFile == "DEATHKNIGHT" then
            classIcon = "interface\\icons\\spell_deathknight_classicon.blp"
        end
    
        local entry = {
            text = coloredClass,
            value = classFile,
            icon = classIcon,
            children = {
                [1] = {
                    text = coloredClass,
                    value = classFile,
                    icon = classIcon,
                    children = {
                        [1] = {
                            text = "No data",
                            value = "NODATA"
                        }
                    }
                }
            }
        }
    
        for specIndex = 1, GetNumSpecializationsForClassID(classID) do
            local _, specName, _, specIcon = LRP.GetSpecializationInfoForClassID(classID, specIndex)
    
            if specName then
                table.insert(
                    entry.children,
                    {
                        text = string.format("|c%s%s|r", colorStr, specName),
                        value = specIndex,
                        icon = specIcon,
                        children = {
                            [1] = {
                                text = "No data",
                                value = "NODATA"
                            }
                        }
                    }
                )
            end
        end
    
        reminderTypeDropdownInfoTable[2].children[classSortOrder[classFile]] = entry
    end
    
    reminderTypeDropdown = LRP:CreateDropdown(
        LRP.reminderConfig,
        "Type",
        reminderTypeDropdownInfoTable,
        function(reminderType, _, _, spellID)
            if reminderType == "TEXT" then
                reminderData.display.type = "TEXT"
    
                textReminderEditBox:Show()
                spellReminderEditBox:Hide()
                hideOnUseCheckButton:Hide()

                reminderColorPicker:SetPoint("LEFT", textReminderEditBox, "RIGHT", spacing, 0)
            elseif reminderType == "SPELLID" then
                reminderData.display.type = "SPELL"
    
                textReminderEditBox:Hide()
                spellReminderEditBox:Show()
                hideOnUseCheckButton:Show()
    
                hideOnUseCheckButton:SetPoint("LEFT", spellReminderEditBoxIcon, "RIGHT", spacing, 0)
                reminderColorPicker:SetPoint("LEFT", hideOnUseCheckButton.title, "RIGHT", spacing, 0)
            elseif reminderType == "SPELL" then
                if spellID == "NODATA" then
                    -- If the user selected "no data", just fall back to spell ID
                    reminderTypeDropdown:SetValue({3})

                    LRP:DisplaySingleExport(reminderID, reminderData)
    
                    return
                end
    
                reminderData.display.type = "SPELL"
                reminderData.display.spellID = spellID
    
                spellReminderEditBox:SetText(spellID)
    
                textReminderEditBox:Hide()
                spellReminderEditBox:Hide()
                hideOnUseCheckButton:Show()
    
                hideOnUseCheckButton:SetPoint("LEFT", reminderTypeDropdown, "RIGHT", spacing, 0)
                reminderColorPicker:SetPoint("LEFT", hideOnUseCheckButton.title, "RIGHT", spacing, 0)
            end

            lingerSlider:SetShown(reminderData.display.type == "SPELL" and reminderData.trigger.hideOnUse)

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    reminderTypeDropdown:SetPoint("TOPLEFT", relativeToDropdown, "BOTTOMLEFT", 0, -30)
    reminderTypeDropdown:SetWidth(140)
    
    -- Text reminder edit box
    textReminderEditBox:SetSize(262, editBoxHeight)
    textReminderEditBox:SetPoint("LEFT", reminderTypeDropdown, "RIGHT", spacing, 0)
    textReminderEditBox:SetMaxLetters(100)

    LRP:AddTooltip(textReminderEditBox, "The text that is displayed when this reminder shows up during an encounter.")
    
    -- Spell reminder edit box
    spellReminderEditBox:SetPoint("LEFT", reminderTypeDropdown, "RIGHT", spacing, 0)
    spellReminderEditBox:SetSize(110, editBoxHeight)
    spellReminderEditBox:SetMaxLetters(10)

    LRP:AddTooltip(
        spellReminderEditBox,
        "ID of the spell that this reminder should show.|n|nYou may enter a spell name here, and it will be converted to spell ID. |cff29ff62This only works if the spell is known by your class|r."
    )
    
    -- Spell reminder edit box icon
    spellReminderEditBoxIcon:SetParent(spellReminderEditBox)
    spellReminderEditBoxIcon:SetSize(iconSize, iconSize)
    spellReminderEditBoxIcon:SetPoint("LEFT", spellReminderEditBox, "RIGHT", spacing, 0)
    
    -- Spell reminder hide-on-use check button
    hideOnUseCheckButton:SetPoint("LEFT", spellReminderEditBoxIcon, "RIGHT", spacing, 0)
    hideOnUseCheckButton:SetChecked(true)
    LRP:AddTooltip(hideOnUseCheckButton, "Whether the reminder should disappear from your screen when you use the selected spell.")
    
    -- TTS check button/time slider
    ttsTimeSlider = LRP:CreateSlider(
        LRP.reminderConfig,
        "At remaining",
        0,
        20,
        function(ttsTime)
            reminderData.tts.time = ttsTime

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    ttsCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "TTS",
        function(newValue)
            reminderData.tts.enabled = newValue
    
            ttsTimeSlider:SetShown(reminderData.tts.enabled)

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    ttsCheckButton:SetPoint("TOPLEFT", reminderTypeDropdown, "BOTTOMLEFT", 0, -30)
    LRP:AddTooltip(ttsCheckButton, "Whether text-to-speech should play for this reminder.")
    
    ttsTimeSlider:SetPoint("LEFT", ttsCheckButton, "RIGHT", 70, 1)
    ttsTimeSlider:SetValue(0)
    ttsTimeSlider:SetShown(reminderData.tts.enabled)
    LRP:AddTooltip(ttsTimeSlider, "At what time (in seconds) remaining on the reminder the text-to-speech should play.")

    -- TTS voice
    ttsVoiceDropdown = LRP:CreateDropdown(
        ttsTimeSlider,
        "Voice",
        GetVoiceDropdownInfoTable(),
        function(voiceID)
            -- If the user manually selected a new voice, play a preview
            if voiceID ~= reminderData.tts.voice then
                local text

                if reminderData.display.type == "TEXT" then
                    text = reminderData.display.text
                elseif tonumber(reminderData.display.spellID) then -- Spell reminder
                    local spellInfo = LRP.GetSpellInfo(reminderData.display.spellID)

                    text = spellInfo.name
                end

                text = text ~= "" and text or "voice preview"

                C_VoiceChat.SpeakText(
                    voiceID,
                    text,
                    Enum.VoiceTtsDestination.LocalPlayback,
                    C_TTSSettings and C_TTSSettings.GetSpeechRate() or 0,
                    LiquidRemindersSaved.settings.ttsVolume
                )
            end

            reminderData.tts.voice = voiceID

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    ttsVoiceDropdown:SetPoint("LEFT", ttsTimeSlider, "RIGHT", spacing, 0)
    ttsVoiceDropdown:SetWidth(120)

    -- TTS alias edit box
    ttsAliasEditBox = LRP:CreateEditBox(
        ttsVoiceDropdown,
        "Alias (optional)",
        function(alias)
            alias = strtrim(alias)

            if alias == "" then
                reminderData.tts.alias = nil
                
                return
            end

            reminderData.tts.alias = alias

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    ttsAliasEditBox:SetHeight(editBoxHeight)
    ttsAliasEditBox:SetPoint("LEFT", ttsVoiceDropdown, "RIGHT", spacing, 0)
    ttsAliasEditBox:SetPoint("RIGHT", LRP.reminderConfig, "RIGHT", -spacing, 0)
    ttsAliasEditBox:SetMaxLetters(50)
    
    LRP:AddTooltip(ttsAliasEditBox, "Alternative text that the TTS should say.|n|nBy default it says the reminder's spell name or text (depending on the type of reminder).")
    
    -- Sound check button/time slider
    soundTimeSlider = LRP:CreateSlider(
        LRP.reminderConfig,
        "At remaining",
        0,
        20,
        function(soundTime)
            reminderData.sound.time = soundTime

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    soundCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "Sound",
        function(soundEnabled)
            reminderData.sound.enabled = soundEnabled
    
            soundTimeSlider:SetShown(reminderData.sound.enabled)

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    soundCheckButton:SetPoint("TOPLEFT", ttsCheckButton, "BOTTOMLEFT", 0, -40)
    LRP:AddTooltip(soundCheckButton, "Whether a sound should play when the reminder shows up.")

    soundTimeSlider:SetPoint("LEFT", soundCheckButton, "RIGHT", 70, 1)
    soundTimeSlider:SetValue(0)
    soundTimeSlider:SetShown(reminderData.sound.enabled)
    LRP:AddTooltip(soundTimeSlider, "At what time (in seconds) remaining on the reminder the sound should play.")

    -- Sound dropdown
    soundDropdownInfoTable = {
        {
            text = "TR Beep",
            value = "Interface\\Addons\\TimelineReminders\\Media\\Sounds\\TR_Beep.mp3"
        }
    }

    local soundHandles = SharedMedia:List("sound")

    for _, handle in ipairs(soundHandles) do
        local soundPath = SharedMedia:Fetch("sound", handle)

        table.insert(
            soundDropdownInfoTable,
            {
                text = handle,
                value = soundPath
            }
        )
    end

    soundDropdown = LRP:CreateDropdown(
        soundTimeSlider,
        "Sound",
        soundDropdownInfoTable,
        function(soundFile)
            -- If the user manually selected a new voice, play a preview
            if soundFile ~= reminderData.sound.file then
                PlaySoundFile(soundFile, LiquidRemindersSaved.settings.soundChannel)
            end

            reminderData.sound.file = soundFile

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    soundDropdown:SetPoint("LEFT", soundTimeSlider, "RIGHT", spacing, 0)
    soundDropdown:SetWidth(120)

    -- Countdown check button/time slider
    countdownTimeSlider = LRP:CreateSlider(
        LRP.reminderConfig,
        "From",
        1,
        10,
        function(start)
            reminderData.countdown.start = start

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    countdownCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "Countdown",
        function(countdownEnabled)
            reminderData.countdown.enabled = countdownEnabled
    
            countdownTimeSlider:SetShown(countdownEnabled)

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    countdownCheckButton:SetPoint("TOPLEFT", soundCheckButton, "BOTTOMLEFT", 0, -40)
    LRP:AddTooltip(countdownCheckButton, "Whether an audible countdown should play")

    countdownTimeSlider:SetPoint("LEFT", countdownCheckButton, "RIGHT", 70, 1)
    countdownTimeSlider:SetValue(3)
    countdownTimeSlider:SetShown(reminderData.sound.enabled)
    LRP:AddTooltip(countdownTimeSlider, "From how many seconds remaining the voice should count down")

    -- Countdown voice dropdown
    countdownVoiceDropdown = LRP:CreateDropdown(
        countdownTimeSlider,
        "Voice",
        {
            {
                text = "Davis",
                value = "Davis"
            },
            {
                text = "Maise",
                value = "Maise"
            },
            {
                text = "Sara",
                value = "Sara"
            },
            {
                text = "Steffan",
                value = "Steffan"
            }
        },
        function(voice)
            -- If the user manually selected a new voice, play a preview
            if voice ~= reminderData.countdown.voice then
                LRP:PlayCountdown(2, voice)

                C_Timer.After(1, function() LRP:PlayCountdown(1, voice) end)
            end

            reminderData.countdown.voice = voice

            LRP:DisplaySingleExport(reminderID, reminderData)
        end,
        {3}
    )

    countdownVoiceDropdown:SetPoint("LEFT", countdownTimeSlider, "RIGHT", spacing, 0)
    countdownVoiceDropdown:SetWidth(120)
    
    -- Glow check button/edit box
    glowNamesEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Name(s)",
        function(glowNames)
            if reminderData.glow then
                reminderData.glow.names = {}
    
                for name in string.gmatch(glowNames, "([^,]+)") do
                    name = strtrim(name):lower():gsub("^%l", string.upper) -- Remove space and make sure only the first letter is capitalised

                    table.insert(reminderData.glow.names, name)
                end
            end

            if glowNames == "" then
                glowNamesEditBox:ShowHighlight(1, 0, 0)

                glowNamesEditBox.secondaryTooltipText = "|cffff0000(Nick)name(s) must be provided for glow(s) to show.|r"
                LRP:RefreshTooltip()
            else
                glowNamesEditBox:HideHighlight()

                glowNamesEditBox.secondaryTooltipText = nil
                LRP:RefreshTooltip()
            end

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    glowCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "Glow",
        function(glow)
            reminderData.glow.enabled = glow
    
            glowNamesEditBox:SetShown(glow)
            glowPreviewFrame:SetShown(glow)

            UpdatePreviewGlow()

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )
    
    glowCheckButton:SetPoint("TOPLEFT", countdownCheckButton, "BOTTOMLEFT", 0, -40)
    LRP:AddTooltip(glowCheckButton, "Whether this reminder should glow unit frames while showing.")
    
    glowNamesEditBox:SetSize(192, editBoxHeight)
    glowNamesEditBox:SetPoint("LEFT", glowCheckButton, "RIGHT", 70, 0)
    glowNamesEditBox:SetMaxLetters(100)
    glowNamesEditBox:SetShown(reminderData.glow.enabled)
    LRP:AddTooltip(
        glowNamesEditBox,
        "Player(s) whose unit frames should glow while the reminder is showing. |cff29ff62Comma separated.|r" ..
        "|n|nCan be either names or nicknames."
    )

    -- Glow type dropdown
    glowTypeDropdown = LRP:CreateDropdown(
        glowNamesEditBox,
        "Glow type",
        {
            [1] = {text = "Pixel glow", value = "PIXEL"},
            [2] = {text = "Auto cast glow", value = "AUTOCAST"},
            [3] = {text = "Button glow", value = "BUTTON"},
            [4] = LRP.isRetail and {text = "Proc glow", value = "PROC"} or nil
        },
        function(glowType)
            reminderData.glow.type = glowType

            UpdatePreviewGlow()

            LRP:DisplaySingleExport(reminderID, reminderData)
        end
    )

    glowTypeDropdown:SetPoint("LEFT", glowNamesEditBox, "RIGHT", spacing, 0)
    glowTypeDropdown:SetWidth(120)

    -- Glow color picker
    glowColorPicker = LRP:CreateColorPicker(
        glowTypeDropdown,
        "Color",
        function(r, g, b)
            reminderData.glow.color = {
                r = r,
                g = g,
                b = b
            }

            UpdatePreviewGlow()

            LRP:DisplaySingleExport(reminderID, reminderData)
        end,
        false
    )

    glowColorPicker:SetSize(20, 20)
    glowColorPicker:SetPoint("LEFT", glowTypeDropdown, "RIGHT", spacing, 0)

    LRP:AddTooltip(glowColorPicker, "Color that the glow will show up in.")

    -- Accept button
    acceptButton = CreateFrame("Button", nil, LRP.reminderConfig)

    acceptButton:SetSize(buttonSize, buttonSize)
    acceptButton:SetPoint("BOTTOMRIGHT", LRP.reminderConfig, "BOTTOM", -4, 8)
    acceptButton:SetNormalAtlas("common-icon-checkmark")
    acceptButton:SetHighlightAtlas("common-icon-checkmark", "ADD")

    acceptButton:SetScript(
        "OnClick",
        function()
            LRP:CreateReminder(reminderID, reminderData)
            LRP:BuildReminderLines()
            LRP.reminderConfig:Hide()
        end
    )

    LRP:AddTooltip(acceptButton, "Update this reminder")

    -- Delete button
    deleteButton = CreateFrame("Button", nil, LRP.reminderConfig)

    deleteButton:SetSize(buttonSize, buttonSize)
    deleteButton:SetPoint("BOTTOMLEFT", LRP.reminderConfig, "BOTTOM", 4, 8)
    deleteButton:SetNormalAtlas("common-icon-redx")
    deleteButton:SetHighlightAtlas("common-icon-redx", "ADD")

    deleteButton:SetScript(
        "OnClick",
        function()
            LRP:ShowConfirmWindow(
                LRP.reminderConfig,
                "Are you sure you want to |cffff0000delete|r this reminder?",
                function()
                    LRP:DeleteReminder(reminderID)
                end
            )
        end
    )

    LRP:AddTooltip(deleteButton, "Delete this reminder")

    -- Make default button
    makeDefaultButton = LRP:CreateButton(
        LRP.reminderConfig,
        "Make default",
        function()
            LRP:ShowConfirmWindow(
                LRP.reminderConfig,
                "Are you sure you want to set the current config as the default?",
                function()
                    LiquidRemindersSaved.settings.defaultReminder = CopyTable(reminderData)

                    LRP:ApplyDefaultSettingsToNote()
                    LRP:BuildReminderLines() -- Tooltips for MRT reminders might change, so rebuild them
                end
            )
        end
    )

    makeDefaultButton:SetPoint("BOTTOMLEFT", LRP.reminderConfig, "BOTTOMLEFT", 8, 8)

    LRP:AddTooltip(makeDefaultButton, "Sets the current config as the default. All newly made reminders will start out identical to it.|n|nThese settings are also applied to MRT reminders.")

    -- Test button
    testButton = LRP:CreateButton(
        LRP.reminderConfig,
        "Test",
        function()
            LRP.anchors.TEXT:HideReminder(reminderID, true)
            LRP.anchors.SPELL:HideReminder(reminderID, true)

            LRP.anchors[reminderData.display.type]:ShowReminder(reminderID, reminderData, 0)
        end
    )

    testButton:SetPoint("LEFT", makeDefaultButton, "RIGHT", 4, 0)

    -- Export button
    exportButton = LRP:CreateButton(
        LRP.reminderConfig,
        "Export",
        function()
            LRP:ToggleSingleExport(reminderID, reminderData)
        end
    )

    exportButton:SetPoint("LEFT", testButton, "RIGHT", 4, 0)

    -- Glow preview frame
    glowPreviewFrame = CreateFrame("Frame", nil, LRP.reminderConfig)

    glowPreviewFrame:SetSize(100, 55)
    glowPreviewFrame:SetPoint("BOTTOMRIGHT", LRP.reminderConfig, "BOTTOMRIGHT", -12, 12)

    glowPreviewFrame.tex = glowPreviewFrame:CreateTexture(nil, "BACKGROUND")
    glowPreviewFrame.tex:SetAllPoints(glowPreviewFrame)
    glowPreviewFrame.tex:SetColorTexture(0.25, 0.25, 0.25)

    glowPreviewFrame.text = glowPreviewFrame:CreateFontString(nil, "OVERLAY")
    glowPreviewFrame.text:SetFontObject(LRFont13)
    glowPreviewFrame.text:SetPoint("CENTER", glowPreviewFrame, "CENTER")
    glowPreviewFrame.text:SetText("Glow|npreview")

    LRP:AddBorder(glowPreviewFrame)
end

local eventFrame = CreateFrame("Frame")

eventFrame:RegisterEvent("VOICE_CHAT_TTS_VOICES_UPDATE")
eventFrame:RegisterEvent("LOADING_SCREEN_DISABLED")

if LRP.isRetail then
	eventFrame:RegisterEvent("LEARNED_SPELL_IN_SKILL_LINE")
end

eventFrame:SetScript(
    "OnEvent",
    function(_, event, ...)
        -- GetSpellBookItemInfo does not return proper spec IDs immediately on login, so we collect data on LOADING_SCREEN_DISABLED
        if event == "LOADING_SCREEN_DISABLED" then
            QueueSpellBookUpdate(true)
        elseif event == "LEARNED_SPELL_IN_SKILL_LINE" then
            QueueSpellBookUpdate()
        elseif event == "VOICE_CHAT_TTS_VOICES_UPDATE" then
            ttsVoiceDropdown:SetInfoTable(GetVoiceDropdownInfoTable())
        end
    end
)